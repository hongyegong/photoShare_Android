/**
 * =================================================================
 * 拖拽类(仅仅在窗口类中使用,但是已经公共出来作为基础服务)
 * 
 * @author      c
 * @email       c@kaihuadian.com
 * @corporation MYOU
 * @date     2011-10-25
 * @version  1.0
 * 
 *  =================================================================
 */

// 导入所依赖的组件
///$(document).imports('myou.event');
//$(document).imports('myou.utils');

/**
 * 公用拖拽方法
 * 
 * 使用只需使用：new MyouDrag().bind( obj ), 进行注册, 可以多个同时使用
 * 
 */
var MyouDrag = function() {
	
	/**
	 * 拖拽对象
	 */
	var target =  null
	,
	
	/**
	 * 发生拖拽时的回调函数
	 */
	moveCallback = null
	,
	/**
	 * 拖拽完成后的回调函数
	 */
	endCallback = null
	,
	/**
	 * 拖动时显示的Border的Div
	 */
	borderDiv = null
	,
	/**
	 * 拖拽时隐藏的对象
	 */
	//hideObj = null
	//,
	/**
	 * 必要的位置信息
	 */
	pos = {
		/** 对象的宽 */
		targetX: null, 
		/** 对象的高 */
		targetY: null,
		/** 对象的鼠标到位置左边框的距离 */
		detalX:  null, 
		/** 对象的鼠标到位置上边框的距离 */
		detalY:  null
	}
	,
	initByMouseDown = function( e, obj, moveCallback, endCallback )
	{
		e = MyouEvent.getE(e);
		this.init(obj, moveCallback, endCallback);
		this.mousedown(e);
	}
	,
	/**
	 * 鼠标按下事件，用来注册一系列的拖拽动作
	 * @param e 事件对象
	 */
	mousedown = function( e )
	{
		e = MyouEvent.getE(e);
		pos.detalX = e.clientX - target.offsetLeft;
		pos.detalY = e.clientY - target.offsetTop;
		pos.targetX = target.clientWidth;
		pos.targetY = target.clientHeight;
		
		// 设置基本效果样式
		var tarJQ = $(target);//.css('opacity', '0.8');
		//if(myou.browser.name === 'msie' && myou.browser.edition < 7) {
			tarJQ.find('iframe').hide();
		//}
		getBordereDivObect(target);
		
		// 捕获鼠标事件
		if (myou.browser.name === 'msie')
		{
			target.setCapture();
			target.onmousemove = mousemove;
			target.onmouseup = mouseup;
			target.onlosecapture = mouseup;
		} else if (document.addEventListener)
		{
			document.addEventListener('mousemove', mousemove, true);
			document.addEventListener('mouseup', mouseup, true);
			window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
		} else
		{
			
			document.onmousemove = mousemove;
			document.onmouseup = mouseup;
		}
		
		// 取消事件的默认行为，取消事件的传播
		MyouEvent.preventDefault(e);
	}
	,
	/**
	 * 鼠标移动事件
	 * @param e 事件对象
	 */
	mousemove = function( e )
	{
		// 兼容浏览器之间的差异性
		e = MyouEvent.getE(e);

		// 计算对象的新位置值,计算对象的left、right值
		var x = e.clientX - pos.detalX, y = e.clientY - pos.detalY;
		
		// 重绘对话框的位置
		if( x > 0 ) 
		{
			//target.style.left = x + 'px';
			borderDiv.style.left = x + 'px';
		}
		if( y > 0 ) 
		{
			//target.style.top = y + 'px';
			borderDiv.style.top = y + 'px';
		}
		
		if( (typeof moveCallback) === 'function' )
		{
			moveCallback( e );
		}
		
		// 取消事件的默认行为及事件的传播
		//MyouEvent.preventDefault(e).stopPropagation(e);
	}
	,
	/**
	 * 鼠标松开事件 即结束拖拽事件
	 * @param e 事件对象
	 */
	mouseup = function(e)
	{
		e = MyouEvent.getE(e);

		MyouEvent.preventDefault(e);

		if (myou.browser.name === 'msie')
		{
			target.releaseCapture();
			target.onmousemove = null;
			target.onmouseup = null;
			target.onmouseout = null;

			// 在测试过程中， 发现firefox也支持setCapture
			MyouEvent.stopPropagation(e);
		} else if (window.captureEvents)
		{
			window.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP);
			document.removeEventListener('mousemove', mousemove, true);
			document.removeEventListener('mouseup', mouseup, true);
			document.removeEventListener('mouseout', mouseup, true);
			e.stopPropagation();
		} else
		{
			document.onmousemove = null;
			document.onmouseup = null;
			document.onmouseout = null;
		}
		
		// 还原对象的默认样式
		//target.style.left = borderDiv.style.left;
		//target.style.top = borderDiv.style.top;
		borderDiv.style.display = 'none';

		var tarJQu = $(target);//.css('opacity', '');
		tarJQu.animate({
			'left': borderDiv.style.left,
			'top': borderDiv.style.top
		}, 220, function() {
			$(this).find('iframe').show();
		});
		if( (typeof endCallback) === 'function' )
		{
			endCallback( e );
		}
		
		// 删除所有的闭包函数
		delete pos, target, moveCallback, endCallback;
		delete init, initByMouseDown, mousedown, mousemove, mouseup;
	},
	getBordereDivObect = function(_obj) {
		if($('#DRAG_BORDER_DIV').length > 0) {
			borderDiv = $('#DRAG_BORDER_DIV').get(0);
		} else {
			borderDiv = document.createElement('div');
			borderDiv.innerHTML = '&nbsp;';
			borderDiv.style.border = '4px groove gray';
			borderDiv.style.position = 'absolute';
			borderDiv.style.backgroundColor = 'blue';
			borderDiv.id = 'DRAG_BORDER_DIV';
			borderDiv.style.zIndex = 2500;
			if(myou.browser.name === 'msie' && myou.browser.edition < 9) {
				borderDiv.style.filter = 'alpha(opacity=20)';
			} else {
				borderDiv.style.opacity = '0.2';
			}
			getTempBox().appendChild(borderDiv);
		}
		borderDiv.style.display = '';
		borderDiv.style.left = target.style.left;
		borderDiv.style.top = target.style.top;
		borderDiv.style.width = _obj.clientWidth - 8 + 'px';
		borderDiv.style.height = _obj.clientHeight - 8 + 'px';
		
	};
	/**
	 * 初始化方法
	 * 
	 * @param toTarget　所作用的窗口
	 * @param obj　拖拽的区域[可选参数]
	 * 
	 */
	this.bind = function( toTarget, obj, _moveCallback, _endCallback )
	{
		// 初始化被拖拽对象
		target = toTarget;
		obj    = obj || target;
		// 获取必要的位置信息
		obj.onmousedown = mousedown;
		// 注册移动时的回调函数
		moveCallback = _moveCallback;
		// 注册完成拖拽的回调函数
		endCallback  = _endCallback;
	};

};